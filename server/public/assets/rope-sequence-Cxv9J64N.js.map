{"version":3,"file":"rope-sequence-Cxv9J64N.js","sources":["../../node_modules/rope-sequence/dist/index.js"],"sourcesContent":["var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nexport default RopeSequence;\n"],"names":["GOOD_LEAF_SIZE","RopeSequence","other","Append","from","to","i","f","result","elt","values","Leaf","prototypeAccessors","start","left","right","leftLen","inner"],"mappings":"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","x_google_ignoreList":[0]}