{"version":3,"file":"sha256-uint8array-DNUmUZDr.js","sources":["../../node_modules/sha256-uint8array/dist/sha256-uint8array.mjs"],"sourcesContent":["/**\n * sha256-uint8array.ts\n */\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311\nconst K = [\n    0x428a2f98 | 0, 0x71374491 | 0, 0xb5c0fbcf | 0, 0xe9b5dba5 | 0,\n    0x3956c25b | 0, 0x59f111f1 | 0, 0x923f82a4 | 0, 0xab1c5ed5 | 0,\n    0xd807aa98 | 0, 0x12835b01 | 0, 0x243185be | 0, 0x550c7dc3 | 0,\n    0x72be5d74 | 0, 0x80deb1fe | 0, 0x9bdc06a7 | 0, 0xc19bf174 | 0,\n    0xe49b69c1 | 0, 0xefbe4786 | 0, 0x0fc19dc6 | 0, 0x240ca1cc | 0,\n    0x2de92c6f | 0, 0x4a7484aa | 0, 0x5cb0a9dc | 0, 0x76f988da | 0,\n    0x983e5152 | 0, 0xa831c66d | 0, 0xb00327c8 | 0, 0xbf597fc7 | 0,\n    0xc6e00bf3 | 0, 0xd5a79147 | 0, 0x06ca6351 | 0, 0x14292967 | 0,\n    0x27b70a85 | 0, 0x2e1b2138 | 0, 0x4d2c6dfc | 0, 0x53380d13 | 0,\n    0x650a7354 | 0, 0x766a0abb | 0, 0x81c2c92e | 0, 0x92722c85 | 0,\n    0xa2bfe8a1 | 0, 0xa81a664b | 0, 0xc24b8b70 | 0, 0xc76c51a3 | 0,\n    0xd192e819 | 0, 0xd6990624 | 0, 0xf40e3585 | 0, 0x106aa070 | 0,\n    0x19a4c116 | 0, 0x1e376c08 | 0, 0x2748774c | 0, 0x34b0bcb5 | 0,\n    0x391c0cb3 | 0, 0x4ed8aa4a | 0, 0x5b9cca4f | 0, 0x682e6ff3 | 0,\n    0x748f82ee | 0, 0x78a5636f | 0, 0x84c87814 | 0, 0x8cc70208 | 0,\n    0x90befffa | 0, 0xa4506ceb | 0, 0xbef9a3f7 | 0, 0xc67178f2 | 0,\n];\nconst algorithms = {\n    sha256: 1,\n};\nexport function createHash(algorithm) {\n    if (algorithm && !algorithms[algorithm] && !algorithms[algorithm.toLowerCase()]) {\n        throw new Error(\"Digest method not supported\");\n    }\n    return new Hash();\n}\nexport class Hash {\n    constructor() {\n        // first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n        this.A = 0x6a09e667 | 0;\n        this.B = 0xbb67ae85 | 0;\n        this.C = 0x3c6ef372 | 0;\n        this.D = 0xa54ff53a | 0;\n        this.E = 0x510e527f | 0;\n        this.F = 0x9b05688c | 0;\n        this.G = 0x1f83d9ab | 0;\n        this.H = 0x5be0cd19 | 0;\n        this._size = 0;\n        this._sp = 0; // surrogate pair\n        if (!sharedBuffer || sharedOffset >= 8000 /* N.allocTotal */) {\n            sharedBuffer = new ArrayBuffer(8000 /* N.allocTotal */);\n            sharedOffset = 0;\n        }\n        this._byte = new Uint8Array(sharedBuffer, sharedOffset, 80 /* N.allocBytes */);\n        this._word = new Int32Array(sharedBuffer, sharedOffset, 20 /* N.allocWords */);\n        sharedOffset += 80 /* N.allocBytes */;\n    }\n    update(data) {\n        // data: string\n        if (\"string\" === typeof data) {\n            return this._utf8(data);\n        }\n        // data: undefined\n        if (data == null) {\n            throw new TypeError(\"Invalid type: \" + typeof data);\n        }\n        const byteOffset = data.byteOffset;\n        const length = data.byteLength;\n        let blocks = (length / 64 /* N.inputBytes */) | 0;\n        let offset = 0;\n        // longer than 1 block\n        if (blocks && !(byteOffset & 3) && !(this._size % 64 /* N.inputBytes */)) {\n            const block = new Int32Array(data.buffer, byteOffset, blocks * 16 /* N.inputWords */);\n            while (blocks--) {\n                this._int32(block, offset >> 2);\n                offset += 64 /* N.inputBytes */;\n            }\n            this._size += offset;\n        }\n        // data: TypedArray | DataView\n        const BYTES_PER_ELEMENT = data.BYTES_PER_ELEMENT;\n        if (BYTES_PER_ELEMENT !== 1 && data.buffer) {\n            const rest = new Uint8Array(data.buffer, byteOffset + offset, length - offset);\n            return this._uint8(rest);\n        }\n        // no more bytes\n        if (offset === length)\n            return this;\n        // data: Uint8Array | Int8Array\n        return this._uint8(data, offset);\n    }\n    _uint8(data, offset) {\n        const { _byte, _word } = this;\n        const length = data.length;\n        offset = offset | 0;\n        while (offset < length) {\n            const start = this._size % 64 /* N.inputBytes */;\n            let index = start;\n            while (offset < length && index < 64 /* N.inputBytes */) {\n                _byte[index++] = data[offset++];\n            }\n            if (index >= 64 /* N.inputBytes */) {\n                this._int32(_word);\n            }\n            this._size += index - start;\n        }\n        return this;\n    }\n    _utf8(text) {\n        const { _byte, _word } = this;\n        const length = text.length;\n        let surrogate = this._sp;\n        for (let offset = 0; offset < length;) {\n            const start = this._size % 64 /* N.inputBytes */;\n            let index = start;\n            while (offset < length && index < 64 /* N.inputBytes */) {\n                let code = text.charCodeAt(offset++) | 0;\n                if (code < 0x80) {\n                    // ASCII characters\n                    _byte[index++] = code;\n                }\n                else if (code < 0x800) {\n                    // 2 bytes\n                    _byte[index++] = 0xC0 | (code >>> 6);\n                    _byte[index++] = 0x80 | (code & 0x3F);\n                }\n                else if (code < 0xD800 || code > 0xDFFF) {\n                    // 3 bytes\n                    _byte[index++] = 0xE0 | (code >>> 12);\n                    _byte[index++] = 0x80 | ((code >>> 6) & 0x3F);\n                    _byte[index++] = 0x80 | (code & 0x3F);\n                }\n                else if (surrogate) {\n                    // 4 bytes - surrogate pair\n                    code = ((surrogate & 0x3FF) << 10) + (code & 0x3FF) + 0x10000;\n                    _byte[index++] = 0xF0 | (code >>> 18);\n                    _byte[index++] = 0x80 | ((code >>> 12) & 0x3F);\n                    _byte[index++] = 0x80 | ((code >>> 6) & 0x3F);\n                    _byte[index++] = 0x80 | (code & 0x3F);\n                    surrogate = 0;\n                }\n                else {\n                    surrogate = code;\n                }\n            }\n            if (index >= 64 /* N.inputBytes */) {\n                this._int32(_word);\n                _word[0] = _word[16 /* N.inputWords */];\n            }\n            this._size += index - start;\n        }\n        this._sp = surrogate;\n        return this;\n    }\n    _int32(data, offset) {\n        let { A, B, C, D, E, F, G, H } = this;\n        let i = 0;\n        offset = offset | 0;\n        while (i < 16 /* N.inputWords */) {\n            W[i++] = swap32(data[offset++]);\n        }\n        for (i = 16 /* N.inputWords */; i < 64 /* N.workWords */; i++) {\n            W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;\n        }\n        for (i = 0; i < 64 /* N.workWords */; i++) {\n            const T1 = (H + sigma1(E) + ch(E, F, G) + K[i] + W[i]) | 0;\n            const T2 = (sigma0(A) + maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        this.A = (A + this.A) | 0;\n        this.B = (B + this.B) | 0;\n        this.C = (C + this.C) | 0;\n        this.D = (D + this.D) | 0;\n        this.E = (E + this.E) | 0;\n        this.F = (F + this.F) | 0;\n        this.G = (G + this.G) | 0;\n        this.H = (H + this.H) | 0;\n    }\n    digest(encoding) {\n        const { _byte, _word } = this;\n        let i = (this._size % 64 /* N.inputBytes */) | 0;\n        _byte[i++] = 0x80;\n        // pad 0 for current word\n        while (i & 3) {\n            _byte[i++] = 0;\n        }\n        i >>= 2;\n        if (i > 14 /* N.highIndex */) {\n            while (i < 16 /* N.inputWords */) {\n                _word[i++] = 0;\n            }\n            i = 0;\n            this._int32(_word);\n        }\n        // pad 0 for rest words\n        while (i < 16 /* N.inputWords */) {\n            _word[i++] = 0;\n        }\n        // input size\n        const bits64 = this._size * 8;\n        const low32 = (bits64 & 0xffffffff) >>> 0;\n        const high32 = (bits64 - low32) / 0x100000000;\n        if (high32)\n            _word[14 /* N.highIndex */] = swap32(high32);\n        if (low32)\n            _word[15 /* N.lowIndex */] = swap32(low32);\n        this._int32(_word);\n        return (encoding === \"hex\") ? this._hex() : this._bin();\n    }\n    _hex() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return hex32(A) + hex32(B) + hex32(C) + hex32(D) + hex32(E) + hex32(F) + hex32(G) + hex32(H);\n    }\n    _bin() {\n        const { A, B, C, D, E, F, G, H, _byte, _word } = this;\n        _word[0] = swap32(A);\n        _word[1] = swap32(B);\n        _word[2] = swap32(C);\n        _word[3] = swap32(D);\n        _word[4] = swap32(E);\n        _word[5] = swap32(F);\n        _word[6] = swap32(G);\n        _word[7] = swap32(H);\n        return _byte.slice(0, 32);\n    }\n}\nconst W = new Int32Array(64 /* N.workWords */);\nlet sharedBuffer;\nlet sharedOffset = 0;\nconst hex32 = num => (num + 0x100000000).toString(16).substr(-8);\nconst swapLE = (c => (((c << 24) & 0xff000000) | ((c << 8) & 0xff0000) | ((c >> 8) & 0xff00) | ((c >> 24) & 0xff)));\nconst swapBE = (c => c);\nconst swap32 = isBE() ? swapBE : swapLE;\nconst ch = (x, y, z) => (z ^ (x & (y ^ z)));\nconst maj = (x, y, z) => ((x & y) | (z & (x | y)));\nconst sigma0 = x => ((x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10));\nconst sigma1 = x => ((x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7));\nconst gamma0 = x => ((x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3));\nconst gamma1 = x => ((x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10));\nfunction isBE() {\n    const buf = new Uint8Array(new Uint16Array([0xFEFF]).buffer); // BOM\n    return (buf[0] === 0xFE);\n}\n"],"names":["K","createHash","algorithm","Hash","sharedBuffer","sharedOffset","data","byteOffset","length","blocks","offset","block","rest","_byte","_word","start","index","text","surrogate","code","A","B","C","D","E","F","G","H","i","W","swap32","gamma1","gamma0","T1","sigma1","ch","T2","sigma0","maj","encoding","bits64","low32","high32","hex32","num","swapLE","c","swapBE","isBE","x","y","z"],"mappings":"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","x_google_ignoreList":[0]}