{"version":3,"file":"prosemirror-tables-B9Tm3w7H.js","sources":["../../node_modules/prosemirror-tables/dist/index.js"],"sourcesContent":["// src/index.ts\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\n\n// src/cellselection.ts\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport {\n  NodeSelection as NodeSelection2,\n  Selection,\n  SelectionRange,\n  TextSelection\n} from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */ new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key) return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos) continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\")\n    throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table), height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n      if (i == rowNode.childCount) break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: \"collision\",\n              row,\n              pos,\n              n: colspan - w\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\n    pos++;\n  }\n  if (width === 0 || height === 0)\n    (problems || (problems = [])).push({ type: \"zero_sized\" });\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n    if (width == -1) width = rowWidth;\n    else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: \"colwidth mismatch\",\n        pos,\n        colwidth: updated\n      });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n  return result;\n}\n\n// src/util.ts\nimport { PluginKey } from \"prosemirror-state\";\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction validateColwidth(value) {\n  if (value === null) {\n    return;\n  }\n  if (!Array.isArray(value)) {\n    throw new TypeError(\"colwidth must be null or an array\");\n  }\n  for (const item of value) {\n    if (typeof item !== \"number\") {\n      throw new TypeError(\"colwidth must be null or an array of numbers\");\n    }\n  }\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: { default: 1, validate: \"number\" },\n    rowspan: { default: 1, validate: \"number\" },\n    colwidth: { default: null, validate: validateColwidth }\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = {\n      default: extraAttrs[prop].default,\n      validate: extraAttrs[prop].validate\n    };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: \"table\" }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{ tag: \"tr\" }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name], role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\")\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\") return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == \"row\") return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\") return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan - n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class _CellSelection extends Selection {\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart\n    );\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size)\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return _CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return _CellSelection.colSelection($anchorCell, $headCell);\n      else return new _CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart\n    );\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = Slice.empty) {\n    const mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content\n      );\n    }\n    const sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1\n    );\n    if (sel) tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart\n      )\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width]\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class _CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell);\n    else return Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth)) break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d)) break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount, curSize = cur.childCount;\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    const child = cur.child(i);\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      changedDescendants(old.child(j), child, offset + 1, f);\n    else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\")\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState) state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\n      );\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell) continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    } else if (prob.type == \"zero_sized\") {\n      const pos = tr.mapping.map(tablePos);\n      tr.delete(pos, pos + table.nodeSize);\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null) first = i;\n      last = i;\n    }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node) nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n\n// src/input.ts\nimport { keydownHandler } from \"prosemirror-keymap\";\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\nimport {\n  Selection as Selection2,\n  TextSelection as TextSelection3\n} from \"prosemirror-state\";\n\n// src/commands.ts\nimport {\n  Fragment as Fragment2,\n  Slice as Slice2\n} from \"prosemirror-model\";\nimport {\n  TextSelection as TextSelection2\n} from \"prosemirror-state\";\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(\n    sel.$anchorCell.pos - tableStart,\n    sel.$headCell.pos - tableStart\n  ) : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\nfunction addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos))\n      );\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos))\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\n      return false;\n  return true;\n}\nfunction addRow(tr, { map, tableStart, table }, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node) cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  const seen = /* @__PURE__ */ new Set();\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (seen.has(pos)) continue;\n    seen.add(pos);\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.height && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    const rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\n    return false;\n  const rect = selectedRect(state), { map } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = Fragment2.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell) continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan\n      ),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\n    );\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state), tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth ? {\n            ...baseAttrs,\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n          } : baseAttrs\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0]\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : void 0\n          )\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter.attrs,\n          [name]: value\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == \"column\" ? {\n          left: rect.left,\n          top: 0,\n          right: rect.right,\n          bottom: rect.map.height\n        } : type == \"row\" ? {\n          left: 0,\n          top: rect.top,\n          right: rect.map.width,\n          bottom: rect.bottom\n        } : rect\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++)\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs\n          );\n      if (tr.steps.length == 0)\n        for (let i = 0; i < cells.length; i++)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        \"column\",\n        rect,\n        types\n      );\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state)) return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr.setSelection(TextSelection2.between($cell, moveCellForward($cell))).scrollIntoView()\n      );\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\n        );\n      return true;\n    }\n  }\n  return false;\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice2(baseContent, 0, 0)\n        );\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n  return true;\n}\n\n// src/copypaste.ts\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nfunction pastedCells(slice) {\n  if (!slice.size) return null;\n  let { content, openStart, openEnd } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice3(cells, left, right)\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(\n      openStart || openEnd ? fitSlice(\n        tableNodeTypes(schema).row,\n        new Slice3(content, openStart, openEnd)\n      ).content : content\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment3.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment3.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row], cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth\n            ),\n            cell.content\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment3.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [], source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n            },\n            cell.content\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment3.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return { width, height, rows };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++) cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\n      );\n    }\n    const emptyRow = types.row.create(null, Fragment3.from(cells)), rows = [];\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top\n        })\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft)\n        )\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs, 0, left - cellLeft)\n        )\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width, bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice3(cells.rows[row - top], 0, 0)\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\n    )\n  );\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = keydownHandler({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(sel.$headCell, dir)\n      );\n    }\n    if (axis != \"horiz\" && !sel.empty) return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(state.doc.resolve(sel.head + dir), dir)\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next) newSel = Selection2.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);\n      else newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view) return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head)\n    );\n  };\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment4.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\n          )\n        ]\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting) $head = $anchor2;\n      else return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2) return stop();\n    }\n    if ($anchor2) setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection3)) return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos) return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\nimport {\n  Decoration as Decoration2,\n  DecorationSet as DecorationSet2\n} from \"prosemirror-view\";\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, defaultCellMinWidth) {\n    this.node = node;\n    this.defaultCellMinWidth = defaultCellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.table.style.setProperty(\n      \"--default-cell-min-width\",\n      `${defaultCellMinWidth}px`\n    );\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumnsOnResize(\n      node,\n      this.colgroup,\n      this.table,\n      this.defaultCellMinWidth\n    );\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row) return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || defaultCellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n      if (!nextDOM) {\n        const col2 = document.createElement(\"col\");\n        col2.style.width = cssWidth;\n        colgroup.appendChild(col2);\n      } else {\n        if (nextDOM.style.width != cssWidth) {\n          nextDOM.style.width = cssWidth;\n        }\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new PluginKey3(\n  \"tableColumnResizing\"\n);\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  defaultCellMinWidth = 100,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        var _a, _b;\n        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;\n        const tableName = tableNodeTypes(state.schema).table.name;\n        if (View && nodeViews) {\n          nodeViews[tableName] = (node, view) => {\n            return new View(node, defaultCellMinWidth, view);\n          };\n        }\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(view, event, handleWidth, lastColumnResizable);\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);\n        }\n      },\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class _ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new _ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0)\n      return new _ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new _ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, lastColumnResizable) {\n  if (!view.editable) return;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState) return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\", handleWidth);\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\", handleWidth);\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  if (!view.editable) return;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {\n  var _a;\n  if (!view.editable) return false;\n  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width }\n    })\n  );\n  function finish(event2) {\n    win.removeEventListener(\"mouseup\", finish);\n    win.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\n      );\n    }\n  }\n  function move(event2) {\n    if (!event2.which) return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2) return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        dragged,\n        defaultCellMinWidth\n      );\n    }\n  }\n  displayColumnWidth(\n    view,\n    pluginState.activeHandle,\n    width,\n    defaultCellMinWidth\n  );\n  win.addEventListener(\"mouseup\", finish);\n  win.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY\n  });\n  if (!found) return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == \"right\") return $cell.pos;\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, resizeMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(resizeMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\n  );\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\n  }\n  if (tr.docChanged) view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, defaultCellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom) return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild,\n    dom,\n    defaultCellMinWidth,\n    col,\n    width\n  );\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  var _a;\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet2.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width;\n    if ((col == map.width - 1 || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      if ((_a = columnResizingPluginKey.getState(state)) == null ? void 0 : _a.dragging) {\n        decorations.push(\n          Decoration2.node(\n            start + cellPos,\n            start + cellPos + table.nodeAt(cellPos).nodeSize,\n            {\n              class: \"column-resize-dragging\"\n            }\n          )\n        );\n      }\n      decorations.push(Decoration2.widget(pos, dom));\n    }\n  }\n  return DecorationSet2.create(state.doc, decorations);\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin2({\n    key: tableEditingKey,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection\n      );\n    }\n  });\n}\nexport {\n  CellBookmark,\n  CellSelection,\n  ResizeState,\n  TableMap,\n  TableView,\n  clipCells as __clipCells,\n  insertCells as __insertCells,\n  pastedCells as __pastedCells,\n  addColSpan,\n  addColumn,\n  addColumnAfter,\n  addColumnBefore,\n  addRow,\n  addRowAfter,\n  addRowBefore,\n  cellAround,\n  cellNear,\n  colCount,\n  columnIsHeader,\n  columnResizing,\n  columnResizingPluginKey,\n  deleteCellSelection,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  findCell,\n  fixTables,\n  fixTablesKey,\n  goToNextCell,\n  handlePaste,\n  inSameTable,\n  isInTable,\n  mergeCells,\n  moveCellForward,\n  nextCell,\n  pointsAtCell,\n  removeColSpan,\n  removeColumn,\n  removeRow,\n  rowIsHeader,\n  selectedRect,\n  selectionCell,\n  setCellAttr,\n  splitCell,\n  splitCellWithType,\n  tableEditing,\n  tableEditingKey,\n  tableNodeTypes,\n  tableNodes,\n  toggleHeader,\n  toggleHeaderCell,\n  toggleHeaderColumn,\n  toggleHeaderRow,\n  updateColumnsOnResize\n};\n"],"names":["readFromCache","addToCache","cache","key","value","cachePos","i","TableMap","width","height","map","problems","pos","curPos","left","top","right","bottom","j","axis","dir","a","b","leftA","rightA","topA","bottomA","leftB","rightB","topB","bottomB","rect","result","seen","row","col","index","table","rowStart","rowEnd","rowEndIndex","computeMap","findWidth","mapPos","colWidths","e","rowNode","cellNode","colspan","rowspan","colwidth","h","start","w","colW","widthIndex","prev","expectedPos","missing","tableMap","badWidths","findBadColWidths","hasRowSpan","rowWidth","prevRow","cell","node","updated","attrs","colWidth","freshColWidth","tableNodeTypes","schema","name","type","role","tableEditingKey","PluginKey","cellAround","$pos","d","cellWrapping","isInTable","state","$head","selectionCell","sel","$cell","cellNear","after","before","pointsAtCell","moveCellForward","inSameTable","$cellA","$cellB","nextCell","tableStart","moved","removeColSpan","n","addColSpan","columnIsHeader","headerCell","CellSelection","_CellSelection","Selection","$anchorCell","$headCell","doc","cells","p","ranges","from","SelectionRange","mapping","tableChanged","TextSelection","rows","rowContent","cellRect","extraLeft","extraRight","Fragment","fragment","Slice","tr","content","mapFrom","$from","$to","f","anchorTop","headTop","anchorBottom","headBottom","anchorRect","headRect","anchorLeft","headLeft","anchorRight","headRight","other","json","anchorCell","headCell","CellBookmark","_CellBookmark","anchor","head","drawCellSelection","Decoration","DecorationSet","isCellBoundarySelection","afterFrom","beforeTo","depth","isTextSelectionAcrossCells","fromCellBoundaryNode","toCellBoundaryNode","normalizeSelection","allowTableNodeSelection","normalize","NodeSelection2","lastCell","fixTablesKey","PluginKey2","changedDescendants","old","cur","offset","oldSize","curSize","outer","child","scan","fixTables","oldState","check","fixTable","tablePos","mustAdd","prob","first","last","end","add","nodes","side","selectedRect","addColumn","refColumn","addColumnBefore","dispatch","addColumnAfter","removeColumn","mapStart","deleteColumn","rowIsHeader","_a","addRow","rowPos","refRow","addRowBefore","addRowAfter","removeRow","nextRow","copy","newPos","deleteRow","isEmpty","c","cellsOverlapRectangle","indexTop","indexLeft","indexBottom","indexRight","mergeCells","Fragment2","mergedPos","mergedCell","cellPos","mapped","splitCell","nodeTypes","splitCellWithType","getCellType","baseAttrs","setCellAttr","deprecated_toggleHeader","types","isHeaderEnabledByType","cellPositions","toggleHeader","options","isHeaderRowEnabled","isHeaderColumnEnabled","selectionStartsAt","cellsRect","newType","relativeCellPos","toggleHeaderCell","findNextCell","lastChild","goToNextCell","direction","TextSelection2","deleteTable","deleteCellSelection","baseContent","Slice2","pastedCells","slice","openStart","openEnd","fitSlice","Slice3","ensureRectangular","widths","r","Fragment3","empty","nodeType","Transform","clipCells","newWidth","newHeight","added","newRows","frag","source","growTable","emptyHead","start2","header","emptyRow","isolateHorizontal","found","cellTop","cellLeft","isolateVertical","updatePos","insertCells","recomp","to","handleKeyDown","keydownHandler","arrow","shiftArrow","maybeSetSelection","selection","view","Selection2","atEndOfCell","$next","newSel","cellSel","handleTripleClick","handlePaste","_","Fragment4","handleMouseDown","startEvent","startDOMCell","domInCell","$anchor","setCellSelection","cellUnderMouse","$anchor2","event","starting","stop","move","_event","TextSelection3","parent","dirStr","dom","mousePos","TableView","defaultCellMinWidth","updateColumnsOnResize","record","colgroup","overrideCol","overrideValue","totalWidth","fixedWidth","nextDOM","hasWidth","cssWidth","col2","columnResizingPluginKey","PluginKey3","columnResizing","handleWidth","cellMinWidth","View","lastColumnResizable","plugin","Plugin","_b","nodeViews","tableName","ResizeState","pluginState","handleMouseMove","handleMouseLeave","handleMouseDown2","handleDecorations","_ResizeState","activeHandle","dragging","action","handle","target","domCellAround","edgeCell","updateHandle","win","currentColWidth","finish","event2","pluginState2","updateColumnWidth","draggedWidth","dragged","displayColumnWidth","domWidth","parts","resizeMinWidth","mapIndex","zeroes","decorations","DecorationSet2","Decoration2","tableEditing","Plugin2","set","deleted"],"mappings":"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","x_google_ignoreList":[0]}