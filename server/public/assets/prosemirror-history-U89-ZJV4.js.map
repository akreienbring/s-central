{"version":3,"file":"prosemirror-history-U89-ZJV4.js","sources":["../../node_modules/prosemirror-history/dist/index.js"],"sourcesContent":["import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' â€” a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(maps) {\n    let result = [];\n    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)\n        maps[i].forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return null;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    return pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist });\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\nfunction buildCommand(redo, scroll) {\n    return (state, dispatch) => {\n        let hist = historyKey.getState(state);\n        if (!hist || (redo ? hist.undone : hist.done).eventCount == 0)\n            return false;\n        if (dispatch) {\n            let tr = histTransaction(hist, state, redo);\n            if (tr)\n                dispatch(scroll ? tr.scrollIntoView() : tr);\n        }\n        return true;\n    };\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = buildCommand(false, true);\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = buildCommand(true, true);\n/**\nA command function that undoes the last change. Don't scroll the\nselection into view.\n*/\nconst undoNoScroll = buildCommand(false, false);\n/**\nA command function that redoes the last undone change. Don't\nscroll the selection into view.\n*/\nconst redoNoScroll = buildCommand(true, false);\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };\n"],"names":["max_empty_items","Branch","items","eventCount","state","preserveItems","end","remap","mapFrom","transform","selection","remaining","addAfter","addBefore","item","i","Item","step","map","histOptions","newItems","oldItems","lastItem","merged","overflow","DEPTH_OVERFLOW","cutOffEvents","from","to","maps","Mapping","mirrorPos","array","rebasedTransform","rebasedCount","rebasedItems","start","mapping","newUntil","iRebased","pos","newMaps","branch","count","upto","events","newItem","last","RopeSequence","n","cutPoint","mirrorOffset","other","HistoryState","done","undone","prevRanges","prevTime","prevComposition","applyTransaction","history","tr","options","historyTr","historyKey","rebased","closeHistoryKey","appended","mustPreserveItems","rangesFor","composition","newGroup","isAdjacentTo","mapRanges","adjacent","result","_from","_to","ranges","histTransaction","redo","pop","added","newHist","cachedPreserveItems","cachedPreserveItemsPlugins","plugins","PluginKey","config","Plugin","hist","view","inputType","command","undo","buildCommand","scroll","dispatch"],"mappings":"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","x_google_ignoreList":[0]}